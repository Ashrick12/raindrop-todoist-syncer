import json
import os
import requests
from typing import Bool 
from urllib.parse import urlparse, parse_qs
import webbrowser

from dotenv import load_dotenv

class RaindropOauthManager():
    """
    Very basic implimentation of a class to manage Raindrop API authorisation. 
          
    Currently has only two uses.  
    
        1) Creates an oauth if none exists, provided the .env
        contains the raindrop client id and client secret. 
        
        2) Can be used to create a new oauth bearer when the old one expires or breaks.
        Will overwrite the old oauth bearer in the .env with the new one.
    
    No error handling etc. 
        
    NOTE: Not used yet! Formalised version of what I used in the prototyping.
            
    """
        
    def __init__(self) -> None:
        self.redirect_uri = 'http://localhost'
        self.RAINDROP_CLIENT_ID = os.getenv("RAINDROP_CLIENT_ID")
        self.RAINDROP_CLIENT_SECRET =  os.getenv("RAINDROP_CLIENT_SECRET")
        
        if os.getenv("RAINDROP_OAUTH_TOKEN") is None:
            self.generate_and_save_new_token_to_env()
        else:
            self.RAINDROP_OAUTH_TOKEN = os.getenv("RAINDROP_OAUTH_TOKEN")
        
    def generate_and_save_new_token_to_env(self) -> Bool:
        """
        Generates an oauth token and saves to .env
        
        """
        self.token = self._get_oauth_token()
        self._write_token_to_env()
        return True
       
    def _get_oauth_token(self) -> str or bool:
        """
        Generates a new oauth token using the raindrop client id, client secret and 
        an authorization code generated by the get authorization code method.
        """
        headers = {'Content-Type': 'application/json'}
        data = {
        'grant_type': 'authorization_code',
        'code': self._get_access_code(),
        'client_id': self.RAINDROP_CLIENT_ID,
        'client_secret': self.RAINDROP_CLIENT_SECRET,
        'redirect_uri': 'http://localhost'
        }

        response = requests.post('https://raindrop.io/oauth/access_token', headers=headers, data=json.dumps(data))

        if response.status_code == 200:
            data = response.json()
            try:
                access_token = data['access_token']
                print(f"Your access token is {access_token}")
                return access_token
            except KeyError:
                print(f"No access token in the response. Full response: {data}")
                return False
        else:
            print(f"Failed to get access token: {response.status_code}, {response.text}")
            return False
            
    def _get_authorization_code(self) -> Bool:
        """
        First step of oauth is to allow "the application" access.  (This is the 
        application you create within Raindrop).  Requires a web uri for which we use
        local host (as defined in the class).
        
        Local host (obviously) will get a load error but that is fine - the code 
        raindrop passes to the url will still work.
        """
        authorize_url = f"https://raindrop.io/oauth/authorize?client_id={self.RAINDROP_CLIENT_ID}&redirect_uri={self.RAINDROP_CLIENT_ID}"
        webbrowser.open(authorize_url)
        code_url = input("Copy and paste the (FULL) returned url: ")
        return True

    def _parse_authorization_code(self, code_url:str) -> str:
        """
        Strips out the authorization code Raindrop return in a URL.
        
        The authorization code should return in this format: 
        localhost/?code=fa71d7d0-2648-40cf-806f-5a549bb4dbb7
               
        """
        # urlparse() parses a URL into six components, 
        # returning a 6-item named tuple: scheme://netloc/path;parameters?query#fragment
        url = urlparse(code_url)

        # parse_qs() parses a query string given as a string argument. 
        # Data are returned as a dictionary. 
        # The dictionary keys are the unique query variable names and 
        # the values are lists of values for each name.
        query_dict = parse_qs(url.query)

        # The authorization code should be under 'code' in the dictionary
        authorization_code = query_dict.get('code')[0]
        return authorization_code
    
    def _write_token_to_env(self):
        """
        Write or overwrite a new oauth token to the .env file.
       
        Could be unstable if I have concurrent instances (unlikely but beware).          
        
        """     
        env_file = '.env'
        token_key = 'RAINDROP_OAUTH_TOKEN'

        with open(env_file, 'r') as file:
            env_lines = file.readlines()

        token_line_index = None
        for i, line in enumerate(env_lines):
            if line.startswith(token_key):
                token_line_index = i
                break

        new_line = f'{token_key}={self.token}\n'
        if token_line_index is not None:
            env_lines[token_line_index] = new_line
        else:
            env_lines.append(new_line)

        with open(env_file, 'w') as file:
            file.writelines(env_lines)
        
        return True

    


 
        
        
        
        